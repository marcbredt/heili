#!/bin/bash

set +x

source ${0%/*}/hinject.config
source ${FUNCTIONS}

usage() {
  ${ECHO} -e "\nUSAGE:     ./${0##*/} [SCENARIOCONFIG]      [HEADERCONFIG]"
  ${ECHO}      "EXAMPLES:  ./${0##*/} "
  ${ECHO}      "           ./${0##*/} hinject.scenarios.xml hinject.headers.xml"
}

# some checks
if [ "${#}" -gt "2" ]; then usage; exit; fi
if [ -f "${1}" -a -f "${2}" ]; then
  ${ECHO} -e "\nI: Using provided configurations."
  SCENARIOCONFIG="${1}"
  HEADERCONFIG="${2}"
else
  ${ECHO} -e "\nI: Using default configurations."
fi
if ! ${XMLLINT} "${SCENARIOCONFIG}" &>/dev/null || \
   !  ${XMLLINT} "${HEADERCONFIG}" &>/dev/null; then
  ${ECHO} -e "\nE: Corrupt configurations. Quitting."
  usage; exit
fi

# cookies - grep on verbose curl responses
# for chrome we are able to gather cookies from profile db usingpython
#kekse="$(${PYTHON} -c 'from python.cookies.chrome import *; chrome_cookies("http://'$(${XMLLINT} --xpath '//global/host/text()' ${HEADERCONFIG})'")' | ${SED} 's/\[\|\]//g' | ${SED} "s/(u'\|')//g" | ${SED} "s/', u'/=/g" | ${SED} 's/, /; /g')"
#${SED} -ri 's@(<cookie replace="\%COOKIE\%">).*(</cookie>)@\1'"${kekse}"'\2@g' ${HEADERCONFIG}

for sid in $(${XMLLINT} --xpath 'string(//scenarios/@order)' "${SCENARIOCONFIG}" | ${TR} ',' ' '); do

  sn="$(${XMLLINT} --xpath 'string(//scenario[@sid="'${sid}'"]/@name)' "${SCENARIOCONFIG}")"
  sdr="$(${XMLLINT} --xpath 'string(//scenario[@sid="'${sid}'"]/@dryrun)' "${SCENARIOCONFIG}")"
  sof="$(${XMLLINT} --xpath 'string(//scenario[@sid="'${sid}'"]/@stoponfail)' "${SCENARIOCONFIG}")"
  ser=0

  # check for active configuration first
  if ! ${XMLLINT} --xpath '//scenario[@sid="'${sid}'" and (@active="y" or not(@active))]' "${SCENARIOCONFIG}" &>/dev/null; then 
    ${ECHO} -e "\nW: No active scenario configuration for sid '${sid}' found. Skipping."
  else

    ${ECHO} -e "\nI: Active scenario configuration '${sn}' for sid '${sid}' found."

    # check that all active headers used are available
    hns=( $(${XMLLINT} --xpath '//scenario[@sid="'${sid}'"]/headers/header[@active="y" or not(@active)]/@*[name()="run" or name()="onfail"]' "${SCENARIOCONFIG}") )

    for hn in ${hns[@]}; do
      hn="$(${ECHO} ${hn} | ${CUT} -d'"' -f2)"
      ${ECHO} -ne "I: Checking for header config '${hn}' ... "
      if ! ${XMLLINT} --xpath '//operations/operation[@name="'${hn}'" and (@active="y" or not(@active))]' "${HEADERCONFIG}" &>/dev/null; then 
        ${ECHO} -e "\e[1m\e[31mfailed\e[0m\e[37m"
        ser=1; break
      else
        ${ECHO} -e "\e[1m\e[92mfound\e[0m\e[37m"
      fi
    done

    # run the scenario if all header configurations available
    if [ "x${ser}" = "x0" ]; then

        # store storeas variables, uppercase variables are accessible for further commands 
        storage=()
        cmd=""
        tmp_data_file=""

        ${ECHO} -e "\nI: Running scenario (${sid}) '${sn}' ..."
        for hid in $(${XMLLINT} --xpath '//scenario[@sid="'${sid}'"]/headers/header[@active="y" or not(@active)]/@hid' "${SCENARIOCONFIG}" 2>/dev/null); do

          hid="$(${ECHO} ${hid} | ${CUT} -d'"' -f2)"
          hn="$(${XMLLINT} --xpath 'string(//scenario[@sid="'${sid}'"]/headers/header[@hid="'${hid}'"]/@run)' "${SCENARIOCONFIG}")"
        
          # export global variables that should be stored in the environment
          # to make their values available to the outside world/main shell lvl
          replace_with_globals "" 1>/dev/null
   
          # get the initial command and replace globals 
          cmd="$(replace_with_globals \
                "$(get_curl_operation_command ${hn})")"

          # replace internals with store[as]-values
          for iv in ${storage[@]}; do
            ${ECHO} "I: Replacing '${iv}' with '$(${EVAL} "${ECHO} \${${iv}}")'"
            # take care of whitespaces (space,tab), newlines already removed
            cmd="$(replace_with_internals \
                  "${cmd}" "%${iv}%#$(${EVAL} "${ECHO} \${${iv}}" "#")")"
          done

          # build data/nondata-command
          data=""
          data_hex_escaped=""
          data_size=""

          if [ "$(${XMLLINT} --xpath '//scenario[@sid="'${sid}'"]/headers/header[@hid="'${hid}'"]/text()' "${SCENARIOCONFIG}" 2>/dev/null)" != "" ]; then
            data="$(replace_with_globals "$(${XMLLINT} --xpath '//scenario[@sid="'${sid}'"]/headers/header[@hid="'${hid}'"]/text()' "${SCENARIOCONFIG}" 2>/dev/null)")"
            data_hex_escaped=$(${EVAL} "${ECHO} -n "${data}"")
            data_size=$(${EVAL} "${ECHO} -ne ${data}" | ${WC} -c)

            # to reduce escapes needed in data sequence due to replace_with_internals echoes twice 
            # the %DATA% placeholder is replaced/sed'ed here
            cmd="$(replace_with_internals "${cmd}" "%CONTENTLEN%#${data_size}" "#")"

            # data last as we need to construct the command manually due to
            #   sed causing "argument list too long"-error
            # passing binary data through option --data{,-binary,-ascii} does not work
            #   therefor pass a temporary file containing the data to --data-binary

            # store data to tmp file
            tmp_data_file="$(${MKTEMP} --tmpdir="${PROJECT_TMP_ROOT}")"
            ${MKDIR} -p "${PROJECT_TMP_ROOT}"
            ${ECHO} -ne "${data_hex_escaped}" > ${tmp_data_file}
            cmd=$(${ECHO} "${cmd}" | ${SED} -e 's#%DATA%#'${tmp_data_file}'#g')

          else
            cmd="$(replace_with_globals \
                  "$(get_curl_operation_command ${hn})" )"
          fi

          # check if store[as]-values set, the command output then needs to be redirected
          # create the response file always to clean it if we run a header without storing
          #   values after on with storing
          rstore="$(${XMLLINT} --xpath 'string(//scenario[@sid="'${sid}'"]/headers/header[@hid="'${hid}'"]/@store)' "${SCENARIOCONFIG}")"
          rstoreas="$(${XMLLINT} --xpath 'string(//scenario[@sid="'${sid}'"]/headers/header[@hid="'${hid}'"]/@storeas)' "${SCENARIOCONFIG}")"

          # always redirect stderr to file to be able to do some
          # evaluation on the response
          ${EVAL} "${EXEC} ${RESPONSEFD}<>${RESPONSEFDFILE}" # open response descriptor
          ${EVAL} "${ECHO} > ${RESPONSEFDFILE}" # clean response of previous header sent
          ${EVAL} "${EXEC} 2>&${RESPONSEFD}" # redeirect curl's v output from stderr
          #if [ "x${rstore}" != "x" -a "x${rstoreas}" != "x" ]; then 
          #  cmd="${cmd} 2>&${RESPONSEFD}" # redirect stderr which contains curl's -v output
                                          #   to header response file
          #else
          #  cmd="${cmd} 2>/dev/null"
          #fi

          # finally run the command
          if [ "x${sdr}" = "xy" ]; then
            if [ "x${data_hex_escaped}" = "x" ]; then 
              ${ECHO} -e "\nI: Dry running command:\n   '${cmd}'"
            else 
              ${ECHO} -ne "\nI: Dry running command:\n   '"
              ${ECHO}      "${cmd}'"
            fi

          else
            if [ "x${data_hex_escaped}" = "x" ]; then 
              ${ECHO} -e "\nI: Running command:\n   '${cmd}'"
            else 
              ${ECHO} -ne "\nI: Running command:\n   '"
              ${ECHO}      "${cmd}'"
            fi

            # pipe to tool needed by content-type definition
            response=$(${EVAL} "${cmd}" | ${XXD} -p -c 1 | ${SED} -r 's/(..)$/\\x\1/g' | tr -d '[\r\n]')
            response_ret="${?}"

            response_show="$(${XMLLINT} --xpath 'string(//scenario[@sid="'${sid}'"]/headers/header[@hid="'${hid}'"]/@response)' "${SCENARIOCONFIG}")"
            if [ "x${response_show}" = "xy" ]; then

              # check for Content-Encoding in response to decode right
              response_decoded=""
              response_encoding="$(${GREP} "^< Content-Encoding: " "${RESPONSEFDFILE}" | ${CUT} -d ' ' -f3- | ${TR} -d '[\r\n]')"

              ${ECHO} "response_encoding='${response_encoding}'"
              case "${response_encoding}" in
                "gzip" ) 
                    response_decoded="$(${ECHO} -ne "${response}" | ${GZIP} -cdk)"
                  ;;
                "" )
                    response_decoded="--- response empty ---"
                  ;;
                * )
                    ${ECHO} -e "\nW: Unsupported Content-Encoding for response." 
                    response_decoded="--- response not decoded ---"
                  ;;
              esac

              ${ECHO} -e "\nI: Showing response:"
              ${ECHO}      "   '${response_decoded}'"
            fi
            
            # command executed succesfully
            if [ "x${response_ret}" = "x0" ]; then

              # store response values
              #TODO: store multiple values from a response header
              #      e.g. "Cookie: __sid=1 __uid=1000 __ts=1234"  => store="Cookie:__sid,__uid"
              if [ "x${rstore}" != "x" -a "x${rstoreas}" != "x" ]; then
                mapcnt=0
                map=( $(${ECHO} ${rstoreas^^} | ${SED} 's/,/ /g') )
                ${ECHO} -e "\n"
                for rv in $(${ECHO} ${rstore} | ${SED} 's/,/ /g'); do
                  if [ "x${map[${mapcnt}]}" = "x" ]; then
                    ${ECHO} -e "\nW: Map element for storing response value '${rv}' not available.\n   Stopping storing response values."
                    break
                  else
                    # get the rv-value from the response
                    rvv="$(${GREP} "^< ${rv}: " "${RESPONSEFDFILE}" | ${CUT} -d ' ' -f3- | ${TR} -d '[\r\n]')"
                    ${ECHO} -e "I: Storing response value '${rv}' (${rvv}) to '${MAP_STR_PREFIX}${map[${mapcnt}]^^}'"
                    # make it available to the environment first
                    ${EVAL} "${EXPORT} ${MAP_STR_PREFIX}${map[${mapcnt}]^^}=\"${rvv}\""  
                    # store access value
                    storage[${#storage[@]}]=${MAP_STR_PREFIX}${map[${mapcnt}]^^}
                  fi
                  ((mapcnt++))
                done
              fi

            # otherwise run the onfail header
            else

              oh="$(${XMLLINT} --xpath 'string(//scenario[@sid="'${sid}'"]/headers/header[@hid="'${hid}'"]/@onfail)' "${SCENARIOCONFIG}")"
              if [ "x${oh}" = "x" ]; then
                ${ECHO} -e "\nI: Executing '${hn}' failed.\n   No onfail header(s) '${oh}' defined."
              else
                ${ECHO} -e "\nI: Executing '${hn}' failed.\n   Running onfail header(s) '${oh}'."
                # TODO: running onfail-header
              fi
   
              # stop scenario executon if errors occured
              if [ "x${sof}" = "xy" ]; then 
                ${ECHO} -e "\nI: Stopping scenario execution for (${sid}) '${sn}' due to previous errors."
                break
              fi

            fi

          fi

          # close opened file descriptors to store curl's response headers 
          #   for each header execution, we always create it
          ${EVAL} "${EXEC} ${RESPONSEFD}>&-"
          #if [ "x${rstore}" != "x" -a "x${rstoreas}" != "x" ]; then 
          #  ${EVAL} "${EXEC} 2>&-" # restore stderr
          #fi
        done

    fi
  fi
done

# clean temporary main filed
${RM} ${RESPONSEFDFILE}
