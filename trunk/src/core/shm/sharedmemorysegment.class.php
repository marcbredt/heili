<?php

namespace core\shm;
use core\util\string\StringUtil as StringUtil;
use core\exception\shm\SegmentException as SegmentException;

/**
 * This class represents a shared memory segment. It can be
 * managed using the SharedMemoryHandler. 
 * @author Marc Bredt
 * @see SharedMemoryHandler
 * @see SharedMemoryManager
 */
class SharedMemorySegment {

  // TODO: remove ftok key ids and therefor replace shm_seg_file/proj_id
  //       with a simple integer, which provides the possibilty to create
  //       more shared memory segments

  /**
   * Default file as the directory the file is in always exists.
   */
  private $shm_seg_file = ".";

  /**
   * Project identifer passed onto ftok().
   * To be able to manage different segments this
   * attribute needs to be setable before creation.
   */
  private $shm_seg_proj_id = "0";

  /**
   * System V IPC key generated by ftok(). 
   * NOTE: Could be any unsigned int and should therefor
   *       be used instead to avoid limitations by ftok()'s
   *       second parameter (project identifier).
   */
  private $shm_seg_key = null;

  /**
   * Shared memory segment id generated by shmop_open().
   * This must be created using flag "n" to avoid race conditions
   * and reallocation for keys generated by ftok().
   */
  private $shm_seg_id = -1;

  /**
   * Size in bytes of the allocated shared memory segment.
   */
  private $shm_seg_size = 1024;

  /**
   * Type of a segment to annotade to a writer/reader, e.g. simple
   * storage (for storing variables) or a fifo queue (for implementing
   * chats). Other types can be stored too but should be regarded
   * in the corresponding reader/writer.
   * Current types 
   * - stor = storage, no freeing mechanisms, exception on full
   * - fifo = first in first out queue
   * - lifo = stack, last in first out queue
   * @see SharedMemoryWriter
   */
  private $shm_seg_type = "stor";
 
  /**
   * The segment type for different usage scenarios.
   * Currently types "stor", "fifo" and "lifo" are supported.
   */
  private $shm_seg_supported_types = array("stor","fifo","lifo");

  /**
   * Constant of valid access types. Currently
   * 0: read only (0400)
   * 1: write only (0200)
   * 2: read and write (0600)
   */
  const shm_seg_valid_access_types = array(0,1,2);

  /** 
   * Access type. Changes the octal rights passed.
   * 0: read only (0400), flag "a" for shmop_open
   * 1: write only (0200), flag "w" for shmop_open + 0200 upon creation
   * 2: read and write (0600), flag "w" for shmop_open
   */
  private $shm_seg_access_type = null;
 
  /**
   * Pins a semaphore onto this shared memory segment to protect
   * read access accessible via a SharedMemoryHandler.
   * @see SharedMemoryHandler
   */
  private $shm_seg_sem_read = null;

  /**
   * Pins a semaphore onto this shared memory segment to protect
   * write access accessible via a SharedMemoryHandler.
   * @see SharedMemoryHandler
   */
  private $shm_seg_sem_write = null;

  /*
   * NOTE: a managableregister should not be used here to store
   *       variables as the proc context would restrict access to
   *       already created/stored variables.
   *
   * NOTE: therefor a variable in a shared memory segment can
   *       look like [varname][s:9:"contents"] where as '[' and ']'
   *       are encapsulators to avoid problems in finding or
   *       addressing variable names.
   *    
   * NOTE: those delimiters and encapsulators therefor need to be
   *       set for/inside a shared memory segment. see class variables
   *       below.
   */

  /**
   * Default encapsulator for left sides of variable shared memory
   * contents. Should be escaped characters for preg_*() funtions.
   * Use StringUtil::escape() to escape the encapsulators if needed.
   * @see StringUtil::escape()
   */
  private $shm_seg_var_eleft = "[";

  /**
   * Default encapsulator for right sides of variable shared memory
   * contents.
   */
  private $shm_seg_var_eright = "]";

  /**
   * Default variable delimiter for variable shared memory contents.
   */
  private $shm_seg_var_delimiter = ";";

  /**
   * Describes the memory layout.
   */
  private $shm_seg_layout = "";

  /**
   * NOTE: Pinning the number of entries for a segment onto any instance
   *       of this object is not useful as instances are only available
   *       during script execution. At the end they will be removed so
   *       the access is not grantable anymore safely. Therefor constant
   *       or predefined keys for shared memory segments should be used
   *       through configurations so any e.g. SharedMemoryManager 
   *       instance is able to get to know about present segments and its
   *       number of entries.
   */

  /**
   * Set the memory layout to store something into a shared memory
   * segment. The layout should always follow the regular expression
   * '[variable][serialize($sth)]'. If the layout differs, e.g. if 
   * one wants to implement anything more complex like a group chat
   * this layout needs to be adjusted to an regular expression like
   * '[from_uid][to_uid][msg_type][serialize(message)]'.
   * Some examples on how to use this function
   * <pre>
   *   set_shm_seg_layout(array("[a-z]+", "[^\\[\\]]"));
   *   set_shm_seg_layout(array("[a-z]+", "[1-9]+[0-9]*", "[^\[\]]+"));
   * </pre>
   * The last should always be something like '[^\[\]]+' as the last
   * element stored in a shared memory segment belonging to this layout 
   * should be a serialized object/variable which MUST NOT contain the
   * encapsulators defined above.
   */
  public function set_shm_seg_layout ($lparams = array()) {

    // set the layout parameters if     
    if(strncmp(gettype($lparams),"array",5)==0 && count($lparams)>2) {

      foreach($lparams as $lp) {    
        $this->shm_seg_layout = $this->shm_seg_layout.
                                StringUtil::escape($this->shm_seg_var_eleft).
                                $lp.
                                StringUtil::escape($this->shm_seg_var_eright);
      }
      $this->shm_seg_layout = $this->shm_seg_layout.
                              $this->shm_seg_var_delimiter;

    // otherwise set the default layout to simply store variables
    } else {
     
      // default layout looks like '[varname][varvalue]' 
      $this->shm_seg_layout = $this->shm_seg_layout.
                              StringUtil::escape($this->shm_seg_var_eleft).
                              "[a-z]+".
                              StringUtil::escape($this->shm_seg_var_eright).
                              StringUtil::escape($this->shm_seg_var_eleft).
                              "[^".
                              StringUtil::escape($this->shm_seg_var_eleft).
                              StringUtil::escape($this->shm_seg_var_eright).
                              "]*".
                              StringUtil::escape($this->shm_seg_var_eright).
                              $this->shm_seg_var_delimiter;
    }

  }

  /**
   * Pin a semaphore onto this shared memory segment to protect
   * read access.
   * @param $sem a valid semaphore
   * @throws ParamNotValidException
   * @see Semaphore
   * @see SharedMemoryHandler
   */
  public function set_shm_seg_sem_read($sem = null) {
    if(strncmp(gettype($sem),"object",6)==0 
       && strncmp(get_class($sem),"core\control\Semaphore",22)==0) {
      $this->shm_seg_sem_read = $sem;
    } else {
      $this->shm_seg_sem_read = null;
      $this->log(__METHOD__.": %", 
                 array(new ParamNotValidException(
                       "sem(core\control\Semaphore)=".
                       StringUtil::get_object_value($sem))));
      throw(new ParamNotValidException(
                       "sem(core\control\Semaphore)=".
                       StringUtil::get_object_value($sem)));
    }
  }

  /**
   * Pin a semaphore onto this shared memory segment to protect
   * write access.
   * @param $sem a valid semaphore
   * @throws ParamNotValidException
   * @see Semaphore
   * @see SharedMemoryHandler
   */
  public function set_shm_seg_sem_write($sem = null) {
    if(strncmp(gettype($sem),"object",6)==0 
       && strncmp(get_class($sem),"core\control\Semaphore",22)==0) {
      $this->shm_seg_sem_write = $sem;
    } else {
      $this->shm_seg_sem_write = null;
      //throw ParamNotValidException
      $this->log(__METHOD__.": %", 
                 array(new ParamNotValidException(
                       "sem(core\control\Semaphore)=".
                       StringUtil::get_object_value($sem))));
      throw(new ParamNotValidException(
                       "sem(core\control\Semaphore)=".
                       StringUtil::get_object_value($sem)));
    }
  }

  /**
  /**
   * Segment id provided by shmop_open().
   * @param $shmop_id segment id.
   */
  public function set_shm_seg_id($shmop_id = -1) {
    if(strncmp(gettype($shmop_id),"integer",7)==0
       && $shmop_id >= -1)
      $this->shm_seg_id = $shmop_id;
    else
      $this->shm_seg_id = -1;
  }

  /**
   * TODO: remove this due to limitations of ftok().
   * Set $this->shm_seg_proj_id. Should be a single character.
   * @param $proj_id preject identifier passed on to ftok().
   * @throws 
   */
  public function set_shm_seg_proj_id($proj_id = "0") {
    if(strncmp(gettype($proj_id),"string",6)==0 
       && strlen($proj_id)==1) 
      $this->shm_seg_proj_id = $proj_id;
    else
      $this->shm_seg_proj_id = "0";
      //throw ParamNotValidException
  }

  /**
   * Generate a key for this segment.
   */
  public function set_shm_seg_key() {
    // TODO: replace ftok. pass an int between -/+(pow(2,32-1)-1)
    $this->shm_seg_key = ftok($this->shm_seg_file,$this->shm_seg_proj_id);
  }

  /**
   * Set the size for this shared memory segment.
   * @param $size in bytes, default 1024
   */
  public function set_shm_seg_size($size = 1024) {
    if(strncmp(gettype($size),"integer",7)==0 && $size>0)
      $this->shm_seg_size = $size;
    else
      $this->shm_seg_size = 1024;
  }

  /**
   * Set the segment type. Currently supported types be SharedMemoryWriter
   * are 'stor', 'fifo', 'lifo'.
   * @param $seg_type segment type
   */
  public function set_shm_seg_type($seg_type = "stor") {

    if(in_array($seg_type, $this->shm_seg_supported_types, true)) {
     
      switch($seg_type) {
        case "stor": $this->shm_seg_type = "stor"; break; 
        case "fifo": $this->shm_seg_type = "fifo"; break; 
        case "lifo": $this->shm_seg_type = "lifo"; break; 
        default:     $this->shm_seg_type = "stor"; break; 
      }

    } else {
      $this->log(__METHOD__.": %", 
                 array(new SegmentException(
                         StringUtil::get_object_string($seg_type),3)));
      throw(new SegmentException(
              StringUtil::get_object_string($seg_type),3));

    }
  }

  /** 
   * Set the access type. Default is read only (0).
   * @param $access_type access type
   * @see SharedMemoryHandler::shm_valid_access_types
   */
  public function set_shm_seg_access_type($access_type = 0) {
    if(in_array($access_type,self::shm_seg_valid_access_types,true))
      return $this->shm_seg_access_type = $access_type;
    else
      return $this->shm_seg_access_type = 0;
  }

  /** 
   * Get the access type for this shared memory segment.
   * 0 - read, 1 - write, 2 - read/write.
   * @return access type
   */
  public function get_shm_seg_access_type() {
    return $this->shm_seg_access_type;
  }

  /**
   * Get the current segment type set for this segment.
   */
  public function get_shm_seg_type() {
    return $this->shm_seg_type;
  }

  /**
   * Get the segment id currently used for this shared memory segment.
   * During allocation this value is temporarily set but reset to -1.
   * @return the segment id set through shmop_open()
   * @see SharedMemoryHandler::alloc()
   * @see SharedMemoryHandler::free()
   * @see SharedMemoryHandler::attach()
   */
  public function get_shm_seg_id() {
    return $this->shm_seg_id;
  }

  public function get_shm_seg_proj_id() {
    return $this->shm_seg_proj_id;
  }

  public function get_shm_seg_key() {
    return $this->shm_seg_key;
  }

  public function get_shm_seg_size() {
    return $this->shm_seg_size;
  }

  public function get_shm_seg_sem_read() {
    return $this->shm_seg_sem_read;
  }

  public function get_shm_seg_sem_write() {
    return $this->shm_seg_sem_write;
  }

  public function get_shm_seg_var_eleft() {
    return $this->shm_seg_var_eleft;
  } 

  public function get_shm_seg_var_eright() {
    return $this->shm_seg_var_eright;
  } 

  public function get_shm_seg_var_delimiter() {
    return $this->shm_seg_var_delimiter;
  } 

  public function get_shm_seg_layout() {
   return $this->shm_seg_layout;
  }

  /**
   * Get a string representation for instances of this class.
   * @return instance of this object as string
   */
  public function __toString() {
    return __CLASS__." (pid=".$this->get_shm_seg_proj_id().
                     ", key=".$this->get_shm_seg_key().
                     ", id=".$this->get_shm_seg_id().
                     ", size=".$this->get_shm_seg_size().
                     ", sem_r=".$this->get_shm_seg_sem_read().
                     ", sem_w=".$this->get_shm_seg_sem_write().
                     ")";
  }

}

?>
